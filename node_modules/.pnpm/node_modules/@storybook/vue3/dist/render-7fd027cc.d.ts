import { App } from 'vue';
import { ArgsStoryFn as ArgsStoryFn$1, RenderContext } from '@storybook/types';
import { V as VueRenderer } from './types-ad933ac1.js';

interface SBBaseType {
    required?: boolean;
    raw?: string;
}
type SBScalarType = SBBaseType & {
    name: 'boolean' | 'string' | 'number' | 'function' | 'symbol';
};
type SBArrayType = SBBaseType & {
    name: 'array';
    value: SBType;
};
type SBObjectType = SBBaseType & {
    name: 'object';
    value: Record<string, SBType>;
};
type SBEnumType = SBBaseType & {
    name: 'enum';
    value: (string | number)[];
};
type SBIntersectionType = SBBaseType & {
    name: 'intersection';
    value: SBType[];
};
type SBUnionType = SBBaseType & {
    name: 'union';
    value: SBType[];
};
type SBOtherType = SBBaseType & {
    name: 'other';
    value: string;
};
type SBType = SBScalarType | SBEnumType | SBArrayType | SBObjectType | SBIntersectionType | SBUnionType | SBOtherType;

type StoryId = string;
type ComponentId = string;
type ComponentTitle = string;
type StoryName = string;
type Tag = string;
interface StoryIdentifier {
    componentId: ComponentId;
    title: ComponentTitle;
    /** @deprecated */
    kind: ComponentTitle;
    id: StoryId;
    name: StoryName;
    /** @deprecated */
    story: StoryName;
    tags: Tag[];
}
interface Parameters {
    [name: string]: any;
}
type ControlType = 'object' | 'boolean' | 'check' | 'inline-check' | 'radio' | 'inline-radio' | 'select' | 'multi-select' | 'number' | 'range' | 'file' | 'color' | 'date' | 'text';
type ConditionalTest = {
    truthy?: boolean;
} | {
    exists: boolean;
} | {
    eq: any;
} | {
    neq: any;
};
type ConditionalValue = {
    arg: string;
} | {
    global: string;
};
type Conditional = ConditionalValue & ConditionalTest;
interface ControlBase {
    [key: string]: any;
    /**
     * @see https://storybook.js.org/docs/api/arg-types#controltype
     */
    type?: ControlType;
    disable?: boolean;
}
type Control = ControlType | false | (ControlBase & (ControlBase | {
    type: 'color';
    /**
     * @see https://storybook.js.org/docs/api/arg-types#controlpresetcolors
     */
    presetColors?: string[];
} | {
    type: 'file';
    /**
     * @see https://storybook.js.org/docs/api/arg-types#controlaccept
     */
    accept?: string;
} | {
    type: 'inline-check' | 'radio' | 'inline-radio' | 'select' | 'multi-select';
    /**
     * @see https://storybook.js.org/docs/api/arg-types#controllabels
     */
    labels?: {
        [options: string]: string;
    };
} | {
    type: 'number' | 'range';
    /**
     * @see https://storybook.js.org/docs/api/arg-types#controlmax
     */
    max?: number;
    /**
     * @see https://storybook.js.org/docs/api/arg-types#controlmin
     */
    min?: number;
    /**
     * @see https://storybook.js.org/docs/api/arg-types#controlstep
     */
    step?: number;
}));
interface InputType {
    /**
     * @see https://storybook.js.org/docs/api/arg-types#control
     */
    control?: Control;
    /**
     * @see https://storybook.js.org/docs/api/arg-types#description
     */
    description?: string;
    /**
     * @see https://storybook.js.org/docs/api/arg-types#if
     */
    if?: Conditional;
    /**
     * @see https://storybook.js.org/docs/api/arg-types#mapping
     */
    mapping?: {
        [key: string]: any;
    };
    /**
     * @see https://storybook.js.org/docs/api/arg-types#name
     */
    name?: string;
    /**
     * @see https://storybook.js.org/docs/api/arg-types#options
     */
    options?: readonly any[];
    /**
     * @see https://storybook.js.org/docs/api/arg-types#table
     */
    table?: {
        [key: string]: unknown;
        /**
         * @see https://storybook.js.org/docs/api/arg-types#tablecategory
         */
        category?: string;
        /**
         * @see https://storybook.js.org/docs/api/arg-types#tabledefaultvalue
         */
        defaultValue?: {
            summary?: string;
            detail?: string;
        };
        /**
         * @see https://storybook.js.org/docs/api/arg-types#tabledisable
         */
        disable?: boolean;
        /**
         * @see https://storybook.js.org/docs/api/arg-types#tablesubcategory
         */
        subcategory?: string;
        /**
         * @see https://storybook.js.org/docs/api/arg-types#tabletype
         */
        type?: {
            summary?: string;
            detail?: string;
        };
    };
    /**
     * @see https://storybook.js.org/docs/api/arg-types#type
     */
    type?: SBType | SBScalarType['name'];
    /**
     * @see https://storybook.js.org/docs/api/arg-types#defaultvalue
     *
     * @deprecated Use `table.defaultValue.summary` instead.
     */
    defaultValue?: any;
    [key: string]: any;
}
interface StrictInputType extends InputType {
    name: string;
    type?: SBType;
}
interface Args {
    [name: string]: any;
}
type StrictArgTypes<TArgs = Args> = {
    [name in keyof TArgs]: StrictInputType;
};
interface Globals {
    [name: string]: any;
}
type Renderer = {
    /** What is the type of the `component` annotation in this renderer? */
    component: unknown;
    /** What does the story function return in this renderer? */
    storyResult: unknown;
    /** What type of element does this renderer render to? */
    canvasElement: unknown;
    T?: unknown;
};
interface StoryContextForEnhancers<TRenderer extends Renderer = Renderer, TArgs = Args> extends StoryIdentifier {
    component?: (TRenderer & {
        T: any;
    })['component'];
    subcomponents?: Record<string, (TRenderer & {
        T: any;
    })['component']>;
    parameters: Parameters;
    initialArgs: TArgs;
    argTypes: StrictArgTypes<TArgs>;
}
interface StoryContextUpdate<TArgs = Args> {
    args?: TArgs;
    globals?: Globals;
    [key: string]: any;
}
type ViewMode = 'story' | 'docs';
interface StoryContextForLoaders<TRenderer extends Renderer = Renderer, TArgs = Args> extends StoryContextForEnhancers<TRenderer, TArgs>, Required<StoryContextUpdate<TArgs>> {
    hooks: unknown;
    viewMode: ViewMode;
    originalStoryFn: StoryFn<TRenderer>;
}
interface StoryContext<TRenderer extends Renderer = Renderer, TArgs = Args> extends StoryContextForLoaders<TRenderer, TArgs> {
    loaded: Record<string, any>;
    abortSignal: AbortSignal;
    canvasElement: TRenderer['canvasElement'];
}
type LegacyStoryFn<TRenderer extends Renderer = Renderer, TArgs = Args> = (context: StoryContext<TRenderer, TArgs>) => TRenderer['storyResult'];
type ArgsStoryFn<TRenderer extends Renderer = Renderer, TArgs = Args> = (args: TArgs, context: StoryContext<TRenderer, TArgs>) => (TRenderer & {
    T: TArgs;
})['storyResult'];
type StoryFn<TRenderer extends Renderer = Renderer, TArgs = Args> = LegacyStoryFn<TRenderer, TArgs> | ArgsStoryFn<TRenderer, TArgs>;

declare const render: ArgsStoryFn$1<VueRenderer>;
declare const setup: (fn: (app: App, storyContext?: StoryContext<VueRenderer>) => unknown) => void;
declare function renderToCanvas({ storyFn, forceRemount, showMain, showException, storyContext, id }: RenderContext<VueRenderer>, canvasElement: VueRenderer['canvasElement']): Promise<() => void>;

export { renderToCanvas as a, render as r, setup as s };
